Subject: [PATCH] Initial Async path finding for mobs.
---
Index: net/minecraft/world/entity/ai/behavior/AcquirePoi.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/net/minecraft/world/entity/ai/behavior/AcquirePoi.java b/net/minecraft/world/entity/ai/behavior/AcquirePoi.java
--- a/net/minecraft/world/entity/ai/behavior/AcquirePoi.java	(revision bf6712a9a58eda0420e00b69fe4390c086256e36)
+++ b/net/minecraft/world/entity/ai/behavior/AcquirePoi.java	(revision 58a785fa3d84e3b94544a3ab35d62a7968e46a21)
@@ -93,31 +93,56 @@
                                 }
                             }
                             // Paper end - optimise POI access
-                            Path path = findPathToPois(mob, set);
-                            if (path != null && path.canReach()) {
-                                BlockPos target = path.getTarget();
-                                poiManager.getType(target).ifPresent(holder -> {
-                                    poiManager.take(acquirablePois, (holder1, blockPos) -> blockPos.equals(target), target, 1);
-                                    memoryAccessor.set(GlobalPos.of(level.dimension(), target));
-                                    entityEventId.ifPresent(id -> level.broadcastEntityEvent(mob, id));
-                                    map.clear();
-                                    level.debugSynchronizers().updatePoi(target);
-                                });
-                            } else {
-                                for (Pair<Holder<PoiType>, BlockPos> pair : set) {
-                                    map.computeIfAbsent(pair.getSecond().asLong(), l -> new AcquirePoi.JitteredLinearRetry(level.random, time));
-                                }
-                            }
-
-                            return true;
-                        }
-                    }
-                )
-        );
-        return acquiringMemory == existingAbsentMemory
-            ? oneShot
-            : BehaviorBuilder.create(instance -> instance.group(instance.absent(existingAbsentMemory)).apply(instance, memoryAccessor -> oneShot));
+                            // Kaiiju start - petal - Async path processing
+                            if (io.papermc.paper.configuration.GlobalConfiguration.get().asyncPathFinding.enabled) {
+                                // await on path async
+                                Path possiblePath = findPathToPois(mob, set);
+                                // wait on the path to be processed
+                                org.dreeam.leaf.async.path.AsyncPathProcessor.awaitProcessing(possiblePath, path -> {
+                                    processPath(acquirablePois, entityEventId, map, memoryAccessor, level, mob, time, poiManager, set, path);
+                                });
+                            } else {
+                                Path path = findPathToPois(mob, set);
+                                processPath(acquirablePois, entityEventId, map, memoryAccessor, level, mob, time, poiManager, set, path);
+                            }
+
+                            return true;
+                        }
+                    }
+                )
+        );
+        return acquiringMemory == existingAbsentMemory
+            ? oneShot
+            : BehaviorBuilder.create(instance -> instance.group(instance.absent(existingAbsentMemory)).apply(instance, memoryAccessor -> oneShot));
+    }
+
+    // Leaf start - Kaiiju - Async path processing
+    private static void processPath(Predicate<Holder<PoiType>> acquirablePois,
+                                    Optional<Byte> entityEventId,
+                                    Long2ObjectMap<JitteredLinearRetry> map,
+                                    net.minecraft.world.entity.ai.behavior.declarative.MemoryAccessor<com.mojang.datafixers.kinds.Const.Mu<com.mojang.datafixers.util.Unit>, GlobalPos> memoryAccessor,
+                                    ServerLevel level,
+                                    PathfinderMob mob,
+                                    long time,
+                                    PoiManager poiManager,
+                                    Set<Pair<Holder<PoiType>, BlockPos>> set,
+                                    @org.jetbrains.annotations.Nullable Path path) {
+        if (path != null && path.canReach()) {
+            BlockPos target = path.getTarget();
+            poiManager.getType(target).ifPresent(holder -> {
+                poiManager.take(acquirablePois, (holder1, blockPos) -> blockPos.equals(target), target, 1);
+                memoryAccessor.set(GlobalPos.of(level.dimension(), target));
+                entityEventId.ifPresent(id -> level.broadcastEntityEvent(mob, id));
+                map.clear();
+                level.debugSynchronizers().updatePoi(target);
+            });
+        } else {
+            for (Pair<Holder<PoiType>, BlockPos> pair : set) {
+                map.computeIfAbsent(pair.getSecond().asLong(), l -> new AcquirePoi.JitteredLinearRetry(level.random, time));
+            }
+        }
     }
+    // Leaf end - Kaiiju - Async path processing
 
     public static @Nullable Path findPathToPois(Mob mob, Set<Pair<Holder<PoiType>, BlockPos>> poiPositions) {
         if (poiPositions.isEmpty()) {
Index: net/minecraft/world/entity/ai/behavior/MoveToTargetSink.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/net/minecraft/world/entity/ai/behavior/MoveToTargetSink.java b/net/minecraft/world/entity/ai/behavior/MoveToTargetSink.java
--- a/net/minecraft/world/entity/ai/behavior/MoveToTargetSink.java	(revision bf6712a9a58eda0420e00b69fe4390c086256e36)
+++ b/net/minecraft/world/entity/ai/behavior/MoveToTargetSink.java	(revision 58a785fa3d84e3b94544a3ab35d62a7968e46a21)
@@ -20,6 +20,7 @@
     private static final int MAX_COOLDOWN_BEFORE_RETRYING = 40;
     private int remainingCooldown;
     private @Nullable Path path;
+    private boolean finishedProcessing;
     private @Nullable BlockPos lastTargetPos;
     private float speedModifier;
 
@@ -51,9 +52,11 @@
             Brain<?> brain = owner.getBrain();
             WalkTarget walkTarget = brain.getMemory(MemoryModuleType.WALK_TARGET).get();
             boolean flag = this.reachedTarget(owner, walkTarget);
-            if (!flag && this.tryComputePath(owner, walkTarget, level.getGameTime())) {
+            if (!io.papermc.paper.configuration.GlobalConfiguration.get().asyncPathFinding.enabled && !flag && this.tryComputePath(owner, walkTarget, level.getGameTime())) { // Kaiiju - petal - async path processing means we can't know if the path is reachable here
                 this.lastTargetPos = walkTarget.getTarget().currentBlockPosition();
                 return true;
+            } else if (io.papermc.paper.configuration.GlobalConfiguration.get().asyncPathFinding.enabled && !flag) {
+                return true; // Kaiiju - async pathfinding
             } else {
                 brain.eraseMemory(MemoryModuleType.WALK_TARGET);
                 if (flag) {
@@ -67,6 +70,8 @@
 
     @Override
     protected boolean canStillUse(ServerLevel level, Mob entity, long gameTime) {
+        if (io.papermc.paper.configuration.GlobalConfiguration.get().asyncPathFinding.enabled && !this.finishedProcessing) return true; // Kaiiju - petal - wait for processing
+
         if (this.path != null && this.lastTargetPos != null) {
             Optional<WalkTarget> memory = entity.getBrain().getMemory(MemoryModuleType.WALK_TARGET);
             boolean flag = memory.map(MoveToTargetSink::isWalkTargetSpectator).orElse(false);
@@ -93,27 +98,99 @@
 
     @Override
     protected void start(ServerLevel level, Mob entity, long gameTime) {
+        // Kaiiju start - petal - start processing
+        if (io.papermc.paper.configuration.GlobalConfiguration.get().asyncPathFinding.enabled) {
+            Brain<?> brain = entity.getBrain();
+            WalkTarget walkTarget = brain.getMemory(MemoryModuleType.WALK_TARGET).get();
+
+            this.finishedProcessing = false;
+            this.lastTargetPos = walkTarget.getTarget().currentBlockPosition();
+            this.path = this.computePath(entity, walkTarget);
+            return;
+        }
+        // Kaiiju end
+
         entity.getBrain().setMemory(MemoryModuleType.PATH, this.path);
         entity.getNavigation().moveTo(this.path, (double)this.speedModifier);
     }
 
     @Override
     protected void tick(ServerLevel level, Mob owner, long gameTime) {
-        Path path = owner.getNavigation().getPath();
-        Brain<?> brain = owner.getBrain();
-        if (this.path != path) {
-            this.path = path;
-            brain.setMemory(MemoryModuleType.PATH, path);
-        }
+        // Kaiiju start - petal - Async path processing
+        if (io.papermc.paper.configuration.GlobalConfiguration.get().asyncPathFinding.enabled) {
+            if (this.path != null && !this.path.isProcessed()) return; // wait for processing
+
+                if (!this.finishedProcessing) {
+                    this.finishedProcessing = true;
+
+                    Brain<?> brain = owner.getBrain();
+                    boolean canReach = this.path != null && this.path.canReach();
+                    if (canReach) {
+                        brain.eraseMemory(MemoryModuleType.CANT_REACH_WALK_TARGET_SINCE);
+                    } else if (!brain.hasMemoryValue(MemoryModuleType.CANT_REACH_WALK_TARGET_SINCE)) {
+                        brain.setMemory(MemoryModuleType.CANT_REACH_WALK_TARGET_SINCE, gameTime);
+                    }
+
+                    if (!canReach) {
+                        Optional<WalkTarget> walkTarget = brain.getMemory(MemoryModuleType.WALK_TARGET);
+                        if (!walkTarget.isPresent()) return;
+
+                        BlockPos blockPos = walkTarget.get().getTarget().currentBlockPosition();
+                        Vec3 vec3 = DefaultRandomPos.getPosTowards((PathfinderMob) owner, 10, 7, Vec3.atBottomCenterOf(blockPos), (float) Math.PI / 2F);
+                        if (vec3 != null) {
+                            // try recalculating the path using a random position
+                            this.path = owner.getNavigation().createPath(vec3.x, vec3.y, vec3.z, 0);
+                            this.finishedProcessing = false;
+                            return;
+                        }
+                    }
+
+                    owner.getBrain().setMemory(MemoryModuleType.PATH, this.path);
+                    owner.getNavigation().moveTo(this.path, this.speedModifier);
+                }
+
+                Path path = owner.getNavigation().getPath();
+                Brain<?> brain = owner.getBrain();
+
+                if (path != null && this.lastTargetPos != null && brain.hasMemoryValue(MemoryModuleType.WALK_TARGET)) {
+                    WalkTarget walkTarget = brain.getMemory(MemoryModuleType.WALK_TARGET).get(); // we know isPresent = true
+                    if (walkTarget.getTarget().currentBlockPosition().distSqr(this.lastTargetPos) > 4.0D) {
+                            this.start(level, owner, gameTime);
+                        }
+                }
+        } else {
+            // Kaiiju end
+            Path path = owner.getNavigation().getPath();
+            Brain<?> brain = owner.getBrain();
+            if (this.path != path) {
+                this.path = path;
+                brain.setMemory(MemoryModuleType.PATH, path);
+            }
 
-        if (path != null && this.lastTargetPos != null) {
-            WalkTarget walkTarget = brain.getMemory(MemoryModuleType.WALK_TARGET).get();
-            if (walkTarget.getTarget().currentBlockPosition().distSqr(this.lastTargetPos) > 4.0 && this.tryComputePath(owner, walkTarget, level.getGameTime())) {
-                this.lastTargetPos = walkTarget.getTarget().currentBlockPosition();
-                this.start(level, owner, gameTime);
+            if (path != null && this.lastTargetPos != null) {
+                WalkTarget walkTarget = brain.getMemory(MemoryModuleType.WALK_TARGET).get();
+                if (walkTarget.getTarget().currentBlockPosition().distSqr(this.lastTargetPos) > 4.0 && this.tryComputePath(owner, walkTarget, level.getGameTime())) {
+                    this.lastTargetPos = walkTarget.getTarget().currentBlockPosition();
+                    this.start(level, owner, gameTime);
+                }
             }
         }
     }
+
+    // Kaiiju start - petal - Async path processing
+    @Nullable
+    private Path computePath(Mob entity, WalkTarget walkTarget) {
+        BlockPos blockPos = walkTarget.getTarget().currentBlockPosition();
+        // don't pathfind outside region
+        //if (!io.papermc.paper.util.TickThread.isTickThreadFor((ServerLevel) entity.level(), blockPos)) return null; // Leaf - Don't need this
+                this.speedModifier = walkTarget.getSpeedModifier();
+        Brain<?> brain = entity.getBrain();
+        if (this.reachedTarget(entity, walkTarget)) {
+                brain.eraseMemory(MemoryModuleType.CANT_REACH_WALK_TARGET_SINCE);
+        }
+        return entity.getNavigation().createPath(blockPos, 0);
+    }
+    // Kaiiju end
 
     private boolean tryComputePath(Mob mob, WalkTarget target, long time) {
         BlockPos blockPos = target.getTarget().currentBlockPosition();
Index: net/minecraft/world/entity/ai/behavior/SetClosestHomeAsWalkTarget.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/net/minecraft/world/entity/ai/behavior/SetClosestHomeAsWalkTarget.java b/net/minecraft/world/entity/ai/behavior/SetClosestHomeAsWalkTarget.java
--- a/net/minecraft/world/entity/ai/behavior/SetClosestHomeAsWalkTarget.java	(revision bf6712a9a58eda0420e00b69fe4390c086256e36)
+++ b/net/minecraft/world/entity/ai/behavior/SetClosestHomeAsWalkTarget.java	(revision 58a785fa3d84e3b94544a3ab35d62a7968e46a21)
@@ -59,25 +59,50 @@
                                         poi -> poi.is(PoiTypes.HOME), predicate, mob.blockPosition(), 48, PoiManager.Occupancy.ANY
                                     )
                                     .collect(Collectors.toSet());
-                                Path path = AcquirePoi.findPathToPois(mob, set);
-                                if (path != null && path.canReach()) {
-                                    BlockPos target = path.getTarget();
-                                    Optional<Holder<PoiType>> type = poiManager.getType(target);
-                                    if (type.isPresent()) {
-                                        walkTarget.set(new WalkTarget(target, speedModifier, 1));
-                                        level.debugSynchronizers().updatePoi(target);
-                                    }
-                                } else if (mutableInt.intValue() < 5) {
-                                    map.long2LongEntrySet().removeIf(entry -> entry.getLongValue() < mutableLong.longValue());
-                                }
-
-                                return true;
-                            } else {
-                                return false;
-                            }
-                        }
-                    }
-                )
-        );
+                                // Kaiiju start - petal - Async path processing
+                                if (io.papermc.paper.configuration.GlobalConfiguration.get().asyncPathFinding.enabled) {
+                                    // await on path async
+                                    Path possiblePath = AcquirePoi.findPathToPois(mob, set);
+
+                                    // wait on the path to be processed
+                                    org.dreeam.leaf.async.path.AsyncPathProcessor.awaitProcessing(possiblePath, path -> {
+                                        processPath(speedModifier, map, mutableLong, walkTarget, level, poiManager, mutableInt, path);
+                                    });
+                                } else {
+                                    // Kaiiju end
+                                    Path path = AcquirePoi.findPathToPois(mob, set);
+                                    processPath(speedModifier, map, mutableLong, walkTarget, level, poiManager, mutableInt, path);
+                                } // Kaiiju - async path processing
+
+                                return true;
+                            } else {
+                                return false;
+                            }
+                        }
+                    }
+                )
+        );
+    }
+
+    // Leaf start - Kaiiju - petal - Async path processing
+    private static void processPath(float speedModifier,
+                                    Long2LongMap map,
+                                    MutableLong mutableLong,
+                                    net.minecraft.world.entity.ai.behavior.declarative.MemoryAccessor<com.mojang.datafixers.kinds.Const.Mu<com.mojang.datafixers.util.Unit>, WalkTarget> walkTarget,
+                                    net.minecraft.server.level.ServerLevel level,
+                                    PoiManager poiManager,
+                                    MutableInt mutableInt,
+                                    @org.jetbrains.annotations.Nullable Path path) {
+        if (path != null && path.canReach()) {
+            BlockPos target = path.getTarget();
+            Optional<Holder<PoiType>> type = poiManager.getType(target);
+            if (type.isPresent()) {
+                walkTarget.set(new WalkTarget(target, speedModifier, 1));
+                level.debugSynchronizers().updatePoi(target);
+            }
+        } else if (mutableInt.intValue() < 5) {
+            map.long2LongEntrySet().removeIf(entry -> entry.getLongValue() < mutableLong.intValue());
+        }
     }
+    // Leaf end - Kaiiju - petal - Async path processing
 }
Index: net/minecraft/world/entity/ai/goal/DoorInteractGoal.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/net/minecraft/world/entity/ai/goal/DoorInteractGoal.java b/net/minecraft/world/entity/ai/goal/DoorInteractGoal.java
--- a/net/minecraft/world/entity/ai/goal/DoorInteractGoal.java	(revision bf6712a9a58eda0420e00b69fe4390c086256e36)
+++ b/net/minecraft/world/entity/ai/goal/DoorInteractGoal.java	(revision 58a785fa3d84e3b94544a3ab35d62a7968e46a21)
@@ -54,7 +54,7 @@
             return false;
         } else {
             Path path = this.mob.getNavigation().getPath();
-            if (path != null && !path.isDone()) {
+            if (path != null && path.isProcessed() && !path.isDone()) { // Kaiiju - async pathfinding - ensure path is processed
                 for (int i = 0; i < Math.min(path.getNextNodeIndex() + 2, path.getNodeCount()); i++) {
                     Node node = path.getNode(i);
                     this.doorPos = new BlockPos(node.x, node.y + 1, node.z);
Index: net/minecraft/world/entity/ai/navigation/AmphibiousPathNavigation.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/net/minecraft/world/entity/ai/navigation/AmphibiousPathNavigation.java b/net/minecraft/world/entity/ai/navigation/AmphibiousPathNavigation.java
--- a/net/minecraft/world/entity/ai/navigation/AmphibiousPathNavigation.java	(revision bf6712a9a58eda0420e00b69fe4390c086256e36)
+++ b/net/minecraft/world/entity/ai/navigation/AmphibiousPathNavigation.java	(revision 58a785fa3d84e3b94544a3ab35d62a7968e46a21)
@@ -12,9 +12,25 @@
         super(mob, level);
     }
 
+    // Kaiiju start - petal - async path processing
+    private static final org.dreeam.leaf.async.path.NodeEvaluatorGenerator nodeEvaluatorGenerator = (org.dreeam.leaf.async.path.NodeEvaluatorFeatures nodeEvaluatorFeatures) -> {
+        AmphibiousNodeEvaluator nodeEvaluator = new AmphibiousNodeEvaluator(false);
+        nodeEvaluator.setCanPassDoors(nodeEvaluatorFeatures.canPassDoors());
+        nodeEvaluator.setCanFloat(nodeEvaluatorFeatures.canFloat());
+        nodeEvaluator.setCanWalkOverFences(nodeEvaluatorFeatures.canWalkOverFences());
+        nodeEvaluator.setCanOpenDoors(nodeEvaluatorFeatures.canOpenDoors());
+        return nodeEvaluator;
+    };
+    // Kaiiju end
+
     @Override
     protected PathFinder createPathFinder(int maxVisitedNodes) {
         this.nodeEvaluator = new AmphibiousNodeEvaluator(false);
+        // Kaiiju start - petal - async path processing
+        if (io.papermc.paper.configuration.GlobalConfiguration.get().asyncPathFinding.enabled) {
+            return new PathFinder(this.nodeEvaluator, maxVisitedNodes, nodeEvaluatorGenerator);
+        }
+        // Kaiiju end
         return new PathFinder(this.nodeEvaluator, maxVisitedNodes);
     }
 
Index: net/minecraft/world/entity/ai/navigation/FlyingPathNavigation.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/net/minecraft/world/entity/ai/navigation/FlyingPathNavigation.java b/net/minecraft/world/entity/ai/navigation/FlyingPathNavigation.java
--- a/net/minecraft/world/entity/ai/navigation/FlyingPathNavigation.java	(revision bf6712a9a58eda0420e00b69fe4390c086256e36)
+++ b/net/minecraft/world/entity/ai/navigation/FlyingPathNavigation.java	(revision 58a785fa3d84e3b94544a3ab35d62a7968e46a21)
@@ -15,9 +15,25 @@
         super(mob, level);
     }
 
+    // Kaiiju start - petal - async path processing
+    private static final org.dreeam.leaf.async.path.NodeEvaluatorGenerator nodeEvaluatorGenerator = (org.dreeam.leaf.async.path.NodeEvaluatorFeatures nodeEvaluatorFeatures) -> {
+        FlyNodeEvaluator nodeEvaluator = new FlyNodeEvaluator();
+        nodeEvaluator.setCanPassDoors(nodeEvaluatorFeatures.canPassDoors());
+        nodeEvaluator.setCanFloat(nodeEvaluatorFeatures.canFloat());
+        nodeEvaluator.setCanWalkOverFences(nodeEvaluatorFeatures.canWalkOverFences());
+        nodeEvaluator.setCanOpenDoors(nodeEvaluatorFeatures.canOpenDoors());
+        return nodeEvaluator;
+    };
+    // Kaiiju end
+
     @Override
     protected PathFinder createPathFinder(int maxVisitedNodes) {
         this.nodeEvaluator = new FlyNodeEvaluator();
+        // Kaiiju start - petal - async path processing
+        if (io.papermc.paper.configuration.GlobalConfiguration.get().asyncPathFinding.enabled) {
+            return new PathFinder(this.nodeEvaluator, maxVisitedNodes, nodeEvaluatorGenerator);
+        }
+        // Kaiiju end
         return new PathFinder(this.nodeEvaluator, maxVisitedNodes);
     }
 
Index: net/minecraft/world/entity/ai/navigation/GroundPathNavigation.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/net/minecraft/world/entity/ai/navigation/GroundPathNavigation.java b/net/minecraft/world/entity/ai/navigation/GroundPathNavigation.java
--- a/net/minecraft/world/entity/ai/navigation/GroundPathNavigation.java	(revision bf6712a9a58eda0420e00b69fe4390c086256e36)
+++ b/net/minecraft/world/entity/ai/navigation/GroundPathNavigation.java	(revision 58a785fa3d84e3b94544a3ab35d62a7968e46a21)
@@ -25,9 +25,25 @@
         super(mob, level);
     }
 
+    // Kaiiju start - petal - async path processing
+    protected static final org.dreeam.leaf.async.path.NodeEvaluatorGenerator nodeEvaluatorGenerator = (org.dreeam.leaf.async.path.NodeEvaluatorFeatures nodeEvaluatorFeatures) -> {
+        WalkNodeEvaluator nodeEvaluator = new WalkNodeEvaluator();
+        nodeEvaluator.setCanPassDoors(nodeEvaluatorFeatures.canPassDoors());
+        nodeEvaluator.setCanFloat(nodeEvaluatorFeatures.canFloat());
+        nodeEvaluator.setCanWalkOverFences(nodeEvaluatorFeatures.canWalkOverFences());
+        nodeEvaluator.setCanOpenDoors(nodeEvaluatorFeatures.canOpenDoors());
+        return nodeEvaluator;
+    };
+    // Kaiiju end
+
     @Override
     protected PathFinder createPathFinder(int maxVisitedNodes) {
         this.nodeEvaluator = new WalkNodeEvaluator();
+        // Kaiiju start - petal - async path processing
+        if (io.papermc.paper.configuration.GlobalConfiguration.get().asyncPathFinding.enabled) {
+            return new PathFinder(this.nodeEvaluator, maxVisitedNodes, nodeEvaluatorGenerator);
+        }
+        // Kaiiju end
         return new PathFinder(this.nodeEvaluator, maxVisitedNodes);
     }
 
Index: net/minecraft/world/entity/ai/navigation/PathNavigation.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/net/minecraft/world/entity/ai/navigation/PathNavigation.java b/net/minecraft/world/entity/ai/navigation/PathNavigation.java
--- a/net/minecraft/world/entity/ai/navigation/PathNavigation.java	(revision bf6712a9a58eda0420e00b69fe4390c086256e36)
+++ b/net/minecraft/world/entity/ai/navigation/PathNavigation.java	(revision 58a785fa3d84e3b94544a3ab35d62a7968e46a21)
@@ -161,6 +161,10 @@
             return null;
         } else if (!this.canUpdatePath()) {
             return null;
+            // Kaiiju start - petal - catch early if it's still processing these positions let it keep processing
+        } else if (this.path instanceof org.dreeam.leaf.async.path.AsyncPath asyncPath && !asyncPath.isProcessed() && asyncPath.hasSameProcessingPositions(targets)) {
+            return this.path;
+            // Kaiiju end
         } else if (this.path != null && !this.path.isDone() && targets.contains(this.targetPos)) {
             return this.path;
         } else {
@@ -187,11 +191,29 @@
             int i = (int)(followRange + regionOffset);
             PathNavigationRegion pathNavigationRegion = new PathNavigationRegion(this.level, blockPos.offset(-i, -i, -i), blockPos.offset(i, i, i));
             Path path = this.pathFinder.findPath(pathNavigationRegion, this.mob, targets, followRange, reachRange, this.maxVisitedNodesMultiplier);
-            profilerFiller.pop();
-            if (path != null && path.getTarget() != null) {
-                this.targetPos = path.getTarget();
-                this.reachRange = reachRange;
-                this.resetStuckTimeout();
+            // Kaiiju start - petal - async path processing
+            if (io.papermc.paper.configuration.GlobalConfiguration.get().asyncPathFinding.enabled) {
+                // assign early a target position. most calls will only have 1 position
+                if (!targets.isEmpty()) this.targetPos = targets.iterator().next();
+
+                org.dreeam.leaf.async.path.AsyncPathProcessor.awaitProcessing(path, processedPath -> {
+                    // check that processing didn't take so long that we calculated a new path
+                    if (processedPath != this.path) return;
+
+                    if (processedPath != null && processedPath.getTarget() != null) {
+                        this.targetPos = processedPath.getTarget();
+                        this.reachRange = reachRange;
+                        this.resetStuckTimeout();
+                    }
+                });
+            } else {
+                // Kaiiju end
+                profilerFiller.pop();
+                if (path != null && path.getTarget() != null) {
+                    this.targetPos = path.getTarget();
+                    this.reachRange = reachRange;
+                    this.resetStuckTimeout();
+                }
             }
 
             return path;
@@ -243,8 +265,8 @@
             if (this.isDone()) {
                 return false;
             } else {
-                this.trimPath();
-                if (this.path.getNodeCount() <= 0) {
+                if (path.isProcessed()) this.trimPath(); // Kaiiju - petal - only trim if processed
+                if (path.isProcessed() && this.path.getNodeCount() <= 0) { // Kaiiju - petal - only check node count if processed
                     return false;
                 } else {
                     this.speedModifier = speedModifier;
@@ -266,6 +288,7 @@
         if (this.hasDelayedRecomputation) {
             this.recomputePath();
         }
+        if (this.path != null && !this.path.isProcessed()) return; // Kaiiju - petal - skip pathfinding if we're still processing
 
         if (!this.isDone()) {
             if (this.canUpdatePath()) {
@@ -294,6 +317,8 @@
     }
 
     protected void followThePath() {
+        if (!this.path.isProcessed()) return; // Kaiiju - petal - skip if not processed
+
         Vec3 tempMobPos = this.getTempMobPos();
         this.maxDistanceToWaypoint = this.mob.getBbWidth() > 0.75F ? this.mob.getBbWidth() / 2.0F : 0.75F - this.mob.getBbWidth() / 2.0F;
         Vec3i nextNodePos = this.path.getNextNodePos();
@@ -450,7 +475,7 @@
     public boolean shouldRecomputePath(BlockPos pos) {
         if (this.hasDelayedRecomputation) {
             return false;
-        } else if (this.path != null && !this.path.isDone() && this.path.getNodeCount() != 0) {
+        } else if (this.path != null && this.path.isProcessed() && !this.path.isDone() && this.path.getNodeCount() != 0) { // Kaiiju - petal - Skip if not processed
             Node endNode = this.path.getEndNode();
             Vec3 vec3 = new Vec3((endNode.x + this.mob.getX()) / 2.0, (endNode.y + this.mob.getY()) / 2.0, (endNode.z + this.mob.getZ()) / 2.0);
             return pos.closerToCenterThan(vec3, this.path.getNodeCount() - this.path.getNextNodeIndex());
Index: net/minecraft/world/entity/ai/navigation/WaterBoundPathNavigation.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/net/minecraft/world/entity/ai/navigation/WaterBoundPathNavigation.java b/net/minecraft/world/entity/ai/navigation/WaterBoundPathNavigation.java
--- a/net/minecraft/world/entity/ai/navigation/WaterBoundPathNavigation.java	(revision bf6712a9a58eda0420e00b69fe4390c086256e36)
+++ b/net/minecraft/world/entity/ai/navigation/WaterBoundPathNavigation.java	(revision 58a785fa3d84e3b94544a3ab35d62a7968e46a21)
@@ -15,11 +15,27 @@
         super(mob, level);
     }
 
+    // Kaiiju start - petal - async path processing
+    private static final org.dreeam.leaf.async.path.NodeEvaluatorGenerator nodeEvaluatorGenerator = (org.dreeam.leaf.async.path.NodeEvaluatorFeatures nodeEvaluatorFeatures) -> {
+        SwimNodeEvaluator nodeEvaluator = new SwimNodeEvaluator(nodeEvaluatorFeatures.allowBreaching());
+        nodeEvaluator.setCanPassDoors(nodeEvaluatorFeatures.canPassDoors());
+        nodeEvaluator.setCanFloat(nodeEvaluatorFeatures.canFloat());
+        nodeEvaluator.setCanWalkOverFences(nodeEvaluatorFeatures.canWalkOverFences());
+        nodeEvaluator.setCanOpenDoors(nodeEvaluatorFeatures.canOpenDoors());
+        return nodeEvaluator;
+    };
+    // Kaiiju end
+
     @Override
     protected PathFinder createPathFinder(int maxVisitedNodes) {
         this.allowBreaching = this.mob.getType() == EntityType.DOLPHIN;
         this.nodeEvaluator = new SwimNodeEvaluator(this.allowBreaching);
         this.nodeEvaluator.setCanPassDoors(false);
+        // Kaiiju start - async path processing
+        if (io.papermc.paper.configuration.GlobalConfiguration.get().asyncPathFinding.enabled) {
+            return new PathFinder(this.nodeEvaluator, maxVisitedNodes, nodeEvaluatorGenerator);
+        }
+        // Kaiiju end
         return new PathFinder(this.nodeEvaluator, maxVisitedNodes);
     }
 
Index: net/minecraft/world/entity/ai/sensing/NearestBedSensor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/net/minecraft/world/entity/ai/sensing/NearestBedSensor.java b/net/minecraft/world/entity/ai/sensing/NearestBedSensor.java
--- a/net/minecraft/world/entity/ai/sensing/NearestBedSensor.java	(revision bf6712a9a58eda0420e00b69fe4390c086256e36)
+++ b/net/minecraft/world/entity/ai/sensing/NearestBedSensor.java	(revision 58a785fa3d84e3b94544a3ab35d62a7968e46a21)
@@ -57,17 +57,31 @@
             java.util.List<Pair<Holder<PoiType>, BlockPos>> poiposes = new java.util.ArrayList<>();
             // don't ask me why it's unbounded. ask mojang.
             io.papermc.paper.util.PoiAccess.findAnyPoiPositions(poiManager, type -> type.is(PoiTypes.HOME), predicate, entity.blockPosition(), 48, PoiManager.Occupancy.ANY, false, Integer.MAX_VALUE, poiposes);
-            Path path = AcquirePoi.findPathToPois(entity, new java.util.HashSet<>(poiposes));
             // Paper end - optimise POI access
-            if (path != null && path.canReach()) {
-                BlockPos target = path.getTarget();
-                Optional<Holder<PoiType>> type = poiManager.getType(target);
-                if (type.isPresent()) {
-                    entity.getBrain().setMemory(MemoryModuleType.NEAREST_BED, target);
-                }
-            } else if (this.triedCount < 5) {
-                this.batchCache.long2LongEntrySet().removeIf(entry -> entry.getLongValue() < this.lastUpdate);
-            }
+            // Kaiiju start - await on async path processing
+            if (io.papermc.paper.configuration.GlobalConfiguration.get().asyncPathFinding.enabled) {
+                Path possiblePath = AcquirePoi.findPathToPois(entity, new java.util.HashSet<>(poiposes));
+                org.dreeam.leaf.async.path.AsyncPathProcessor.awaitProcessing(possiblePath, path -> {
+                    processPath(entity, poiManager, path);
+                });
+            } else {
+                // Kaiiju end
+                Path path = AcquirePoi.findPathToPois(entity, new java.util.HashSet<>(poiposes));
+                processPath(entity, poiManager, path);
+            } // Kaiiju - async path processing
+        }
+    }
+
+    // Leaf start - Kaiiju - await on async path processing
+    private void processPath(Mob entity, PoiManager poiManager, @org.jetbrains.annotations.Nullable Path path) {
+        if (path != null && path.canReach()) {
+            BlockPos target = path.getTarget();
+            Optional<Holder<PoiType>> type = poiManager.getType(target);
+            if (type.isPresent()) {
+                entity.getBrain().setMemory(MemoryModuleType.NEAREST_BED, target);
+            }
+        } else if (this.triedCount < 5) {
+            this.batchCache.long2LongEntrySet().removeIf(entry -> entry.getLongValue() < this.lastUpdate);
         }
     }
 }
Index: net/minecraft/world/entity/animal/bee/Bee.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/net/minecraft/world/entity/animal/bee/Bee.java b/net/minecraft/world/entity/animal/bee/Bee.java
--- a/net/minecraft/world/entity/animal/bee/Bee.java	(revision bf6712a9a58eda0420e00b69fe4390c086256e36)
+++ b/net/minecraft/world/entity/animal/bee/Bee.java	(revision 58a785fa3d84e3b94544a3ab35d62a7968e46a21)
@@ -856,6 +856,14 @@
                             Bee.this.pathfindRandomlyTowards(Bee.this.hivePos);
                         }
                     } else {
+                        // Leaf start - async path processing fix
+                        // Wait for path processing before making navigation decisions
+                        Path currentPath = Bee.this.navigation.getPath();
+                        if (io.papermc.paper.configuration.GlobalConfiguration.get().asyncPathFinding.enabled && currentPath != null && !currentPath.isProcessed()) {
+                            return;
+                        }
+                        // Leaf end - async path processing fix
+
                         boolean flag = this.pathfindDirectlyTowards(Bee.this.hivePos);
                         if (!flag) {
                             this.dropAndBlacklistHive();
@@ -909,7 +917,7 @@
                 return true;
             } else {
                 Path path = Bee.this.navigation.getPath();
-                return path != null && path.getTarget().equals(pos) && path.canReach() && path.isDone();
+                return path != null && path.isProcessed() && path.getTarget().equals(pos) && path.canReach() && path.isDone(); // Kaiiju - petal - ensure path is processed
             }
         }
     }
Index: net/minecraft/world/entity/animal/frog/Frog.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/net/minecraft/world/entity/animal/frog/Frog.java b/net/minecraft/world/entity/animal/frog/Frog.java
--- a/net/minecraft/world/entity/animal/frog/Frog.java	(revision bf6712a9a58eda0420e00b69fe4390c086256e36)
+++ b/net/minecraft/world/entity/animal/frog/Frog.java	(revision 58a785fa3d84e3b94544a3ab35d62a7968e46a21)
@@ -420,9 +420,25 @@
             return pathType != PathType.WATER_BORDER && super.canCutCorner(pathType);
         }
 
+        // Kaiiju start - petal - async path processing
+        private static final org.dreeam.leaf.async.path.NodeEvaluatorGenerator nodeEvaluatorGenerator = (org.dreeam.leaf.async.path.NodeEvaluatorFeatures nodeEvaluatorFeatures) -> {
+            Frog.FrogNodeEvaluator nodeEvaluator = new Frog.FrogNodeEvaluator(true);
+            nodeEvaluator.setCanPassDoors(nodeEvaluatorFeatures.canPassDoors());
+            nodeEvaluator.setCanFloat(nodeEvaluatorFeatures.canFloat());
+            nodeEvaluator.setCanWalkOverFences(nodeEvaluatorFeatures.canWalkOverFences());
+            nodeEvaluator.setCanOpenDoors(nodeEvaluatorFeatures.canOpenDoors());
+            return nodeEvaluator;
+        };
+        // Kaiiju end
+
         @Override
         protected PathFinder createPathFinder(int maxVisitedNodes) {
             this.nodeEvaluator = new Frog.FrogNodeEvaluator(true);
+            // Kaiiju start - petal - async path processing
+            if (io.papermc.paper.configuration.GlobalConfiguration.get().asyncPathFinding.enabled) {
+                return new PathFinder(this.nodeEvaluator, maxVisitedNodes, nodeEvaluatorGenerator);
+            }
+            // Kaiiju end
             return new PathFinder(this.nodeEvaluator, maxVisitedNodes);
         }
     }
Index: net/minecraft/world/entity/animal/rabbit/Rabbit.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/net/minecraft/world/entity/animal/rabbit/Rabbit.java b/net/minecraft/world/entity/animal/rabbit/Rabbit.java
--- a/net/minecraft/world/entity/animal/rabbit/Rabbit.java	(revision bf6712a9a58eda0420e00b69fe4390c086256e36)
+++ b/net/minecraft/world/entity/animal/rabbit/Rabbit.java	(revision 58a785fa3d84e3b94544a3ab35d62a7968e46a21)
@@ -509,6 +509,14 @@
 
         @Override
         public void tick() {
+            // Leaf start - async pathfinding - don't make movement decisions with unprocessed paths
+            if (io.papermc.paper.configuration.GlobalConfiguration.get().asyncPathFinding.enabled) {
+                Path path = this.rabbit.getNavigation().getPath();
+                if (path != null && !path.isProcessed()) {
+                    return; // Wait for path processing before making movement decisions
+                }
+            }
+            // Leaf end - async pathfinding
             if (this.rabbit.onGround() && !this.rabbit.jumping && !((Rabbit.RabbitJumpControl)this.rabbit.jumpControl).wantJump()) {
                 this.rabbit.setSpeedModifier(0.0);
             } else if (this.hasWanted() || this.operation == MoveControl.Operation.JUMPING) {
Index: net/minecraft/world/entity/boss/enderdragon/EnderDragon.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java b/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java
--- a/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java	(revision bf6712a9a58eda0420e00b69fe4390c086256e36)
+++ b/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java	(revision 58a785fa3d84e3b94544a3ab35d62a7968e46a21)
@@ -831,13 +831,13 @@
     }
 
     private Path reconstructPath(Node start, Node finish) {
-        List<Node> list = Lists.newArrayList();
+        List<Node> list = new java.util.concurrent.CopyOnWriteArrayList<Node>();
         Node node = finish;
-        list.add(0, finish);
+        list.addFirst(finish);
 
         while (node.cameFrom != null) {
             node = node.cameFrom;
-            list.add(0, node);
+            list.addFirst(node);
         }
 
         return new Path(list, new BlockPos(finish.x, finish.y, finish.z), true);
Index: net/minecraft/world/entity/monster/Strider.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/net/minecraft/world/entity/monster/Strider.java b/net/minecraft/world/entity/monster/Strider.java
--- a/net/minecraft/world/entity/monster/Strider.java	(revision bf6712a9a58eda0420e00b69fe4390c086256e36)
+++ b/net/minecraft/world/entity/monster/Strider.java	(revision 58a785fa3d84e3b94544a3ab35d62a7968e46a21)
@@ -504,9 +504,26 @@
             super(strider, level);
         }
 
+        // Kaiiju start - petal - async path processing
+        private static final org.dreeam.leaf.async.path.NodeEvaluatorGenerator nodeEvaluatorGenerator = (org.dreeam.leaf.async.path.NodeEvaluatorFeatures nodeEvaluatorFeatures) -> {
+            WalkNodeEvaluator nodeEvaluator = new WalkNodeEvaluator();
+            nodeEvaluator.setCanPassDoors(nodeEvaluatorFeatures.canPassDoors());
+            nodeEvaluator.setCanFloat(nodeEvaluatorFeatures.canFloat());
+            nodeEvaluator.setCanWalkOverFences(nodeEvaluatorFeatures.canWalkOverFences());
+            nodeEvaluator.setCanOpenDoors(nodeEvaluatorFeatures.canOpenDoors());
+            return nodeEvaluator;
+        };
+        // Kaiiju end
+
+
         @Override
         protected PathFinder createPathFinder(int maxVisitedNodes) {
             this.nodeEvaluator = new WalkNodeEvaluator();
+            // Kaiiju start - async path processing
+            if (io.papermc.paper.configuration.GlobalConfiguration.get().asyncPathFinding.enabled) {
+                return new PathFinder(this.nodeEvaluator, maxVisitedNodes, nodeEvaluatorGenerator);
+            }
+            // Kaiiju end
             return new PathFinder(this.nodeEvaluator, maxVisitedNodes);
         }
 
Index: net/minecraft/world/entity/monster/warden/Warden.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/net/minecraft/world/entity/monster/warden/Warden.java b/net/minecraft/world/entity/monster/warden/Warden.java
--- a/net/minecraft/world/entity/monster/warden/Warden.java	(revision bf6712a9a58eda0420e00b69fe4390c086256e36)
+++ b/net/minecraft/world/entity/monster/warden/Warden.java	(revision 58a785fa3d84e3b94544a3ab35d62a7968e46a21)
@@ -545,6 +545,16 @@
             @Override
             protected PathFinder createPathFinder(int maxVisitedNodes) {
                 this.nodeEvaluator = new WalkNodeEvaluator();
+                // Kaiiju start - petal - async path processing
+                if (io.papermc.paper.configuration.GlobalConfiguration.get().asyncPathFinding.enabled) {
+                    return new PathFinder(this.nodeEvaluator, maxVisitedNodes, GroundPathNavigation.nodeEvaluatorGenerator) {
+                        @Override
+                        protected float distance(Node first, Node second) {
+                            return first.distanceToXZ(second);
+                        }
+                    };
+                }
+                // Kaiiju end
                 return new PathFinder(this.nodeEvaluator, maxVisitedNodes) {
                     @Override
                     protected float distance(Node first, Node second) {
Index: net/minecraft/world/entity/monster/zombie/Drowned.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/net/minecraft/world/entity/monster/zombie/Drowned.java b/net/minecraft/world/entity/monster/zombie/Drowned.java
--- a/net/minecraft/world/entity/monster/zombie/Drowned.java	(revision bf6712a9a58eda0420e00b69fe4390c086256e36)
+++ b/net/minecraft/world/entity/monster/zombie/Drowned.java	(revision 58a785fa3d84e3b94544a3ab35d62a7968e46a21)
@@ -250,7 +250,7 @@
 
     protected boolean closeToNextPos() {
         Path path = this.getNavigation().getPath();
-        if (path != null) {
+        if (path != null && path.isProcessed() ) {
             BlockPos target = path.getTarget();
             if (target != null) {
                 double d = this.distanceToSqr(target.getX(), target.getY(), target.getZ());
Index: net/minecraft/world/level/pathfinder/Path.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/net/minecraft/world/level/pathfinder/Path.java b/net/minecraft/world/level/pathfinder/Path.java
--- a/net/minecraft/world/level/pathfinder/Path.java	(revision bf6712a9a58eda0420e00b69fe4390c086256e36)
+++ b/net/minecraft/world/level/pathfinder/Path.java	(revision 58a785fa3d84e3b94544a3ab35d62a7968e46a21)
@@ -11,7 +11,7 @@
 import net.minecraft.world.phys.Vec3;
 import org.jspecify.annotations.Nullable;
 
-public final class Path {
+public class Path {
     public static final StreamCodec<FriendlyByteBuf, Path> STREAM_CODEC = StreamCodec.of((buffer, value) -> value.writeToStream(buffer), Path::createFromStream);
     public final List<Node> nodes;
     private Path.@Nullable DebugData debugData;
@@ -27,6 +27,18 @@
         this.reached = reached;
     }
 
+    // Kaiiju start - petal - async path processing
+    /**
+     * checks if the path is completely processed in the case of it being computed async
+     *
+     * @return true if the path is processed
+     */
+    public boolean isProcessed() {
+        return true;
+    }
+    // Kaiiju end
+
+
     public void advance() {
         this.nextNodeIndex++;
     }
@@ -98,6 +110,7 @@
     }
 
     public boolean sameAs(@Nullable Path path) {
+        if (path == this) return true; // Kaiiju - petal - short circuit
         return path != null && this.nodes.equals(path.nodes);
     }
 
@@ -145,7 +158,7 @@
         boolean _boolean = buffer.readBoolean();
         int _int = buffer.readInt();
         BlockPos blockPos = buffer.readBlockPos();
-        List<Node> list = buffer.readList(Node::createFromStream);
+        List<Node> list = new java.util.concurrent.CopyOnWriteArrayList<Node>( buffer.readList(Node::createFromStream) );
         Path.DebugData debugData = Path.DebugData.read(buffer);
         Path path = new Path(list, blockPos, _boolean);
         path.debugData = debugData;
@@ -185,7 +198,7 @@
     }
 
     public Path copy() {
-        Path path = new Path(this.nodes, this.target, this.reached);
+        Path path = new Path( new java.util.concurrent.CopyOnWriteArrayList<Node>( this.nodes ), this.target, this.reached);
         path.debugData = this.debugData;
         path.nextNodeIndex = this.nextNodeIndex;
         return path;
Index: net/minecraft/world/level/pathfinder/PathFinder.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/net/minecraft/world/level/pathfinder/PathFinder.java b/net/minecraft/world/level/pathfinder/PathFinder.java
--- a/net/minecraft/world/level/pathfinder/PathFinder.java	(revision bf6712a9a58eda0420e00b69fe4390c086256e36)
+++ b/net/minecraft/world/level/pathfinder/PathFinder.java	(revision 58a785fa3d84e3b94544a3ab35d62a7968e46a21)
@@ -18,6 +18,7 @@
 import net.minecraft.world.entity.Mob;
 import net.minecraft.world.level.PathNavigationRegion;
 import org.jspecify.annotations.Nullable;
+import org.dreeam.leaf.async.path.NodeEvaluatorGenerator;
 
 public class PathFinder {
     private static final float FUDGING = 1.5F;
@@ -26,10 +27,21 @@
     public final NodeEvaluator nodeEvaluator;
     private final BinaryHeap openSet = new BinaryHeap();
     private BooleanSupplier captureDebug = () -> false;
+    private static final org.slf4j.Logger LOGGER = com.mojang.logging.LogUtils.getClassLogger();
 
-    public PathFinder(NodeEvaluator nodeEvaluator, int maxVisitedNodes) {
+    @Nullable
+    private final NodeEvaluatorGenerator nodeEvaluatorGenerator;
+
+    public PathFinder(NodeEvaluator nodeEvaluator, int maxVisitedNodes, @Nullable NodeEvaluatorGenerator nodeEvaluatorGenerator) { // Kaiiju - petal - add nodeEvaluatorGenerator
         this.nodeEvaluator = nodeEvaluator;
         this.maxVisitedNodes = maxVisitedNodes;
+        // Kaiiju start - petal - support nodeEvaluatorgenerators
+        this.nodeEvaluatorGenerator = nodeEvaluatorGenerator;
+    }
+
+    public PathFinder(NodeEvaluator nodeEvaluator, int maxVisitedNodes) {
+        this(nodeEvaluator, maxVisitedNodes, null);
+        // Kaiiju end
     }
 
     public void setCaptureDebug(BooleanSupplier captureDebug) {
@@ -41,28 +53,76 @@
     }
 
     public @Nullable Path findPath(PathNavigationRegion region, Mob mob, Set<BlockPos> targets, float maxRange, int reachRange, float maxVisitedNodesMultiplier) {
-        this.openSet.clear();
-        this.nodeEvaluator.prepare(region, mob);
-        Node start = this.nodeEvaluator.getStart();
+        if (! io.papermc.paper.configuration.GlobalConfiguration.get().asyncPathFinding.enabled)
+            this.openSet.clear(); // Kaiiju - petal - it's always cleared in processPath
+        // Kaiiju start - petal - use a generated evaluator if we have one otherwise run sync
+        NodeEvaluator nodeEvaluatorTemp = this.nodeEvaluator;
+        boolean useAsyncMethod = false;
+        if( this.nodeEvaluatorGenerator != null && io.papermc.paper.configuration.GlobalConfiguration.get().asyncPathFinding.enabled ) {
+            useAsyncMethod = true;
+            nodeEvaluatorTemp = org.dreeam.leaf.async.path.NodeEvaluatorCache.takeNodeEvaluator(this.nodeEvaluatorGenerator, this.nodeEvaluator);
+        }
+
+        NodeEvaluator nodeEvaluator = nodeEvaluatorTemp;
+
+        nodeEvaluator.prepare(region, mob);
+        Node start = nodeEvaluator.getStart();
+        // Kaiiju end
         if (start == null) {
+            org.dreeam.leaf.async.path.NodeEvaluatorCache.removeNodeEvaluator(nodeEvaluator); // Kaiiju - petal - handle nodeEvaluatorGenerator
             return null;
         } else {
             // Paper start - Perf: remove streams and optimize collection
             List<Map.Entry<Target, BlockPos>> map = Lists.newArrayList();
             for (BlockPos pos : targets) {
-                map.add(new java.util.AbstractMap.SimpleEntry<>(this.nodeEvaluator.getTarget(pos.getX(), pos.getY(), pos.getZ()), pos));
+                map.add(new java.util.AbstractMap.SimpleEntry<>(nodeEvaluator.getTarget(pos.getX(), pos.getY(), pos.getZ()), pos)); // Kaiiju - petal - handle nodeEvaluatorGenerator
             }
             // Paper end - Perf: remove streams and optimize collection
-            Path path = this.findPath(start, map, maxRange, reachRange, maxVisitedNodesMultiplier);
-            this.nodeEvaluator.done();
-            return path;
+            // Kaiiju start - petal - async path processing
+            if (!useAsyncMethod) {
+                // run sync :(
+                org.dreeam.leaf.async.path.NodeEvaluatorCache.removeNodeEvaluator(nodeEvaluator);
+                Path path = this.findPath(start, map, maxRange, reachRange, maxVisitedNodesMultiplier);
+                return path;
+            }
+
+            return new org.dreeam.leaf.async.path.AsyncPath(Lists.newArrayList(), targets, () -> {
+                try {
+                    return this.processPath(nodeEvaluator, start, map, maxRange, reachRange, maxVisitedNodesMultiplier);
+                } catch (Exception e) {
+                    LOGGER.error("Error while finding a path", e);
+                    e.printStackTrace();
+                    return null;
+                } finally {
+                    nodeEvaluator.done();
+                    org.dreeam.leaf.async.path.NodeEvaluatorCache.returnNodeEvaluator(nodeEvaluator);
+                }
+            });
+            // Kaiiju end
         }
     }
 
     private @Nullable Path findPath(Node node, List<Map.Entry<Target, BlockPos>> positions, float maxRange, int reachRange, float maxVisitedNodesMultiplier) { // Paper - optimize collection
-        ProfilerFiller profilerFiller = Profiler.get();
-        profilerFiller.push("find_path");
-        profilerFiller.markForCharting(MetricCategory.PATH_FINDING);
+        //ProfilerFiller profilerFiller = Profiler.get();
+        //profilerFiller.push("find_path");
+        //profilerFiller.markForCharting(MetricCategory.PATH_FINDING);
+
+        // Kaiiju start - petal - split pathfinding into the original sync method for compat and processing for delaying
+        try {
+            return this.processPath(this.nodeEvaluator, node, positions, maxRange, reachRange, maxVisitedNodesMultiplier);
+        } catch (Exception e) {
+
+            e.printStackTrace();
+            return null;
+        } finally {
+            this.nodeEvaluator.done();
+        }
+    }
+
+    private synchronized @org.jetbrains.annotations.NotNull Path processPath(NodeEvaluator nodeEvaluator, Node node, List<Map.Entry<Target, BlockPos>> positions, float maxRange, int accuracy, float searchDepthMultiplier) { // sync to only use the caching functions in this class on a single thread
+        org.apache.commons.lang3.Validate.isTrue(!positions.isEmpty()); // ensure that we have at least one position, which means we'll always return a path
+        // Kaiiju end
+
         // Set<Target> set = targetPositions.keySet(); // Paper - unused
         node.g = 0.0F;
         node.h = this.getBestH(node, positions); // Paper - optimize collection
@@ -73,7 +133,7 @@
         Set<Node> set1 = asBoolean ? new HashSet<>() : Set.of();
         int i = 0;
         List<Map.Entry<Target, BlockPos>> entryList = Lists.newArrayListWithExpectedSize(positions.size()); // Paper - optimize collection
-        int i1 = (int)(this.maxVisitedNodes * maxVisitedNodesMultiplier);
+        int i1 = (int)(this.maxVisitedNodes * searchDepthMultiplier);
 
         while (!this.openSet.isEmpty()) {
             if (++i >= i1) {
@@ -87,7 +147,7 @@
             for (int positionIndex = 0, size = positions.size(); positionIndex < size; positionIndex++) {
                 final Map.Entry<Target, BlockPos> entry = positions.get(positionIndex);
                 Target target = entry.getKey();
-                if (node1.distanceManhattan(target) <= reachRange) {
+                if (node1.distanceManhattan(target) <= accuracy) {
                     target.setReached();
                     entryList.add(entry);
                     // Paper end - Perf: remove streams and optimize collection
@@ -103,7 +163,7 @@
             }
 
             if (!(node1.distanceTo(node) >= maxRange)) {
-                int neighbors = this.nodeEvaluator.getNeighbors(this.neighbors, node1);
+                int neighbors = nodeEvaluator.getNeighbors(this.neighbors, node1); // Kaiiju - petal - use provided nodeEvaluator
 
                 for (int i2 = 0; i2 < neighbors; i2++) {
                     Node node2 = this.neighbors[i2];
@@ -137,7 +197,7 @@
                 best = path;
             }
         }
-        profilerFiller.pop();
+        //profilerFiller.pop();
         if(asBoolean && best != null) {
             Set<Target> set = Sets.newHashSet();
             for(Map.Entry<Target, BlockPos> entry : positions) {
@@ -145,6 +205,7 @@
             }
             best.setDebug(this.openSet.getHeap(), set1.toArray(Node[]::new), set);
         }
+        //noinspection ConstantConditions // Kaiiju - petal - ignore this warning, we know that the above loop always runs at least once since positions is not empty
         return best;
         // Paper end - Perf: remove streams and optimize collection
     }
@@ -169,13 +230,13 @@
     }
 
     private Path reconstructPath(Node node, BlockPos targetPos, boolean reachesTarget) {
-        List<Node> list = Lists.newArrayList();
+        List<Node> list = new java.util.concurrent.CopyOnWriteArrayList<Node>();
         Node node1 = node;
-        list.add(0, node);
+        list.addFirst(node);
 
         while (node1.cameFrom != null) {
             node1 = node1.cameFrom;
-            list.add(0, node1);
+            list.addFirst(node1);
         }
 
         return new Path(list, targetPos, reachesTarget);
Index: net/minecraft/world/level/pathfinder/SwimNodeEvaluator.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/net/minecraft/world/level/pathfinder/SwimNodeEvaluator.java b/net/minecraft/world/level/pathfinder/SwimNodeEvaluator.java
--- a/net/minecraft/world/level/pathfinder/SwimNodeEvaluator.java	(revision bf6712a9a58eda0420e00b69fe4390c086256e36)
+++ b/net/minecraft/world/level/pathfinder/SwimNodeEvaluator.java	(revision 58a785fa3d84e3b94544a3ab35d62a7968e46a21)
@@ -22,6 +22,8 @@
         this.allowBreaching = allowBreaching;
     }
 
+    public boolean getAllowBreaching() { return this.allowBreaching; }
+
     @Override
     public void prepare(PathNavigationRegion level, Mob mob) {
         super.prepare(level, mob);
